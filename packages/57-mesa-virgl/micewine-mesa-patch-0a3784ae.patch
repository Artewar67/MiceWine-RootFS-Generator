diff --git a/bin/install_megadrivers.py b/bin/install_megadrivers.py
index 60ee4576c60..0903975c942 100644
--- a/bin/install_megadrivers.py
+++ b/bin/install_megadrivers.py
@@ -24,7 +24,17 @@
 
 import argparse
 import os
+import shutil
 
+def link(src, dest):
+    shutil.copyfile(src, dest)
+
+def unlink(src):
+    os.remove(src)
+
+os.link = link
+
+os.unlink = unlink
 
 def main():
     parser = argparse.ArgumentParser()
diff --git a/meson.build b/meson.build
index 6d10219f067..4d899d82554 100644
--- a/meson.build
+++ b/meson.build
@@ -1361,7 +1361,7 @@ if not ['linux'].contains(host_machine.system())
   endif
 endif
 
-foreach h : ['xlocale.h', 'linux/futex.h', 'endian.h', 'dlfcn.h', 'sys/shm.h',
+foreach h : ['linux/futex.h', 'endian.h', 'dlfcn.h', 'sys/shm.h',
              'cet.h', 'pthread_np.h', 'renderdoc_app.h', 'sys/inotify.h']
   if cc.check_header(h)
     pre_args += '-DHAVE_@0@'.format(h.to_upper().underscorify())
@@ -1371,11 +1371,9 @@ endforeach
 functions_to_detect = {
   'strtof': '',
   'mkostemp': '',
-  'memfd_create': '',
   'random_r': '',
   'flock': '',
   'strtok_r': '',
-  'getrandom': '',
   'qsort_s': '',
   'posix_fallocate': '',
 }
diff --git a/src/freedreno/vulkan/tu_device.cc b/src/freedreno/vulkan/tu_device.cc
index 430cf3c1642..67aa6b54886 100644
--- a/src/freedreno/vulkan/tu_device.cc
+++ b/src/freedreno/vulkan/tu_device.cc
@@ -2759,6 +2759,14 @@ tu_AllocateMemory(VkDevice _device,
       uint64_t client_address = 0;
       BITMASK_ENUM(tu_bo_alloc_flags) alloc_flags = TU_BO_ALLOC_NO_FLAGS;
 
+      const VkExportMemoryAllocateInfo *export_info = vk_find_struct_const(
+         pAllocateInfo->pNext, EXPORT_MEMORY_ALLOCATE_INFO);
+      if (export_info && (export_info->handleTypes &
+                          (VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT |
+                           VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT))) {
+         alloc_flags |= TU_BO_ALLOC_SHAREABLE;
+      }
+
       const VkMemoryOpaqueCaptureAddressAllocateInfo *replay_info =
          vk_find_struct_const(pAllocateInfo->pNext,
                               MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO);
diff --git a/src/freedreno/vulkan/tu_knl.h b/src/freedreno/vulkan/tu_knl.h
index e9293e3d08b..06bd24eeaa9 100644
--- a/src/freedreno/vulkan/tu_knl.h
+++ b/src/freedreno/vulkan/tu_knl.h
@@ -21,6 +21,7 @@ enum tu_bo_alloc_flags
    TU_BO_ALLOC_ALLOW_DUMP = 1 << 0,
    TU_BO_ALLOC_GPU_READ_ONLY = 1 << 1,
    TU_BO_ALLOC_REPLAYABLE = 1 << 2,
+   TU_BO_ALLOC_SHAREABLE = 1 << 3,
 };
 
 /* Define tu_timeline_sync type based on drm syncobj for a point type
@@ -53,6 +54,7 @@ struct tu_bo {
    uint32_t bo_list_idx;
 
    bool implicit_sync : 1;
+   int dmabuf_fd;
 };
 
 struct tu_knl {
diff --git a/src/freedreno/vulkan/tu_knl_kgsl.cc b/src/freedreno/vulkan/tu_knl_kgsl.cc
index 0c2f16c496c..a9f7e9a0eb4 100644
--- a/src/freedreno/vulkan/tu_knl_kgsl.cc
+++ b/src/freedreno/vulkan/tu_knl_kgsl.cc
@@ -11,6 +11,7 @@
 #include <stdint.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
+#include <linux/dma-heap.h>
 
 #include "msm_kgsl.h"
 #include "vk_util.h"
@@ -18,6 +19,7 @@
 #include "util/u_debug.h"
 #include "util/u_vector.h"
 #include "util/libsync.h"
+#include "util/os_file.h"
 #include "util/timespec.h"
 
 #include "tu_cmd_buffer.h"
@@ -67,6 +69,57 @@ kgsl_submitqueue_close(struct tu_device *dev, uint32_t queue_id)
    safe_ioctl(dev->physical_device->local_fd, IOCTL_KGSL_DRAWCTXT_DESTROY, &req);
 }
 
+static int
+dmabuf_alloc(uint64_t size)
+{
+   int ret;
+   int dma_heap = open("/dev/dma_heap/system", O_RDONLY);
+
+   if (dma_heap < 0) {
+      int ion_heap = open("/dev/ion", O_RDONLY);
+
+      if (ion_heap < 0)
+         return -1;
+
+      struct ion_allocation_data {
+         __u64 len;
+         __u32 heap_id_mask;
+         __u32 flags;
+         __u32 fd;
+         __u32 unused;
+      } alloc_data = {
+         .len = size,
+         /* ION_HEAP_SYSTEM | ION_SYSTEM_HEAP_ID */
+         .heap_id_mask = (1U << 0) | (1U << 25),
+         .flags = 0, /* uncached */
+      };
+
+      ret = safe_ioctl(ion_heap, _IOWR('I', 0, struct ion_allocation_data),
+                      &alloc_data);
+
+      close(ion_heap);
+
+      if (ret)
+         return -1;
+
+      return alloc_data.fd;
+   } else {
+      struct dma_heap_allocation_data alloc_data = {
+         .len = size,
+         .fd_flags = O_RDWR | O_CLOEXEC,
+      };
+
+      ret = safe_ioctl(dma_heap, DMA_HEAP_IOCTL_ALLOC, &alloc_data);
+
+      close(dma_heap);
+
+      if (ret)
+         return -1;
+
+      return alloc_data.fd;
+   }
+}
+
 static VkResult
 kgsl_bo_init(struct tu_device *dev,
              struct tu_bo **out_bo,
@@ -78,6 +131,21 @@ kgsl_bo_init(struct tu_device *dev,
 {
    assert(client_iova == 0);
 
+   if (flags & TU_BO_ALLOC_SHAREABLE) {
+      int fd = dmabuf_alloc(size);
+
+      if (fd < 0) {
+         return vk_errorf(dev, VK_ERROR_OUT_OF_DEVICE_MEMORY,
+                       "DMABUF_ALLOC failed (%s)", strerror(errno));
+      }
+
+      VkResult res = tu_bo_init_dmabuf(dev, out_bo, size, fd);
+
+      close(fd);
+
+      return res;
+   }
+
    struct kgsl_gpumem_alloc_id req = {
       .size = size,
    };
@@ -113,6 +181,7 @@ kgsl_bo_init(struct tu_device *dev,
       .iova = req.gpuaddr,
       .name = tu_debug_bos_add(dev, req.mmapsize, name),
       .refcnt = 1,
+      .dmabuf_fd = -1,
    };
 
    *out_bo = bo;
@@ -162,6 +231,7 @@ kgsl_bo_init_dmabuf(struct tu_device *dev,
       .iova = info_req.gpuaddr,
       .name = tu_debug_bos_add(dev, info_req.size, "dmabuf"),
       .refcnt = 1,
+      .dmabuf_fd = os_dupfd_cloexec(fd),
    };
 
    *out_bo = bo;
@@ -172,9 +242,7 @@ kgsl_bo_init_dmabuf(struct tu_device *dev,
 static int
 kgsl_bo_export_dmabuf(struct tu_device *dev, struct tu_bo *bo)
 {
-   tu_stub();
-
-   return -1;
+   return os_dupfd_cloexec(bo->dmabuf_fd);
 }
 
 static VkResult
@@ -183,6 +251,15 @@ kgsl_bo_map(struct tu_device *dev, struct tu_bo *bo)
    if (bo->map)
       return VK_SUCCESS;
 
+   if (bo->dmabuf_fd != -1) {
+      void *map = mmap(0, bo->size, PROT_READ | PROT_WRITE, MAP_SHARED, bo->dmabuf_fd, 0);
+
+      if (map != MAP_FAILED) {
+         bo->map = map;
+         return VK_SUCCESS;
+      }
+   }
+
    uint64_t offset = bo->gem_handle << 12;
    void *map = mmap(0, bo->size, PROT_READ | PROT_WRITE, MAP_SHARED,
                     dev->physical_device->local_fd, offset);
@@ -210,6 +287,9 @@ kgsl_bo_finish(struct tu_device *dev, struct tu_bo *bo)
    if (bo->map)
       munmap(bo->map, bo->size);
 
+   if (bo->dmabuf_fd != -1)
+      close(bo->dmabuf_fd);
+
    struct kgsl_gpumem_free_id req = {
       .id = bo->gem_handle
    };
diff --git a/src/gallium/drivers/llvmpipe/lp_scene.h b/src/gallium/drivers/llvmpipe/lp_scene.h
index 41dffd78ad3..3a9c58cfb64 100644
--- a/src/gallium/drivers/llvmpipe/lp_scene.h
+++ b/src/gallium/drivers/llvmpipe/lp_scene.h
@@ -39,6 +39,8 @@
 #include "lp_rast.h"
 #include "lp_debug.h"
 
+void *reallocarray(void *ptr, size_t nelem, size_t elsize);
+
 struct lp_scene_queue;
 struct lp_rast_state;
 
diff --git a/src/util/log.c b/src/util/log.c
index 96ee7cf98b7..f6883246f6e 100644
--- a/src/util/log.c
+++ b/src/util/log.c
@@ -36,10 +36,6 @@
 #include "util/u_process.h"
 #endif
 
-#if DETECT_OS_ANDROID
-#include <android/log.h>
-#endif
-
 #if DETECT_OS_WINDOWS
 #include <windows.h>
 #endif
@@ -78,11 +74,7 @@ mesa_log_init_once(void)
 
    if (!(mesa_log_control & MESA_LOG_CONTROL_LOGGER_MASK)) {
       /* pick the default loggers */
-#if DETECT_OS_ANDROID
-      mesa_log_control |= MESA_LOG_CONTROL_ANDROID;
-#else
       mesa_log_control |= MESA_LOG_CONTROL_FILE;
-#endif
 
 #if DETECT_OS_WINDOWS
       /* stderr from windows applications without console is not usually
@@ -265,50 +257,6 @@ logger_syslog(enum mesa_log_level level,
 
 #endif /* DETECT_OS_UNIX */
 
-#if DETECT_OS_ANDROID
-
-static inline android_LogPriority
-level_to_android(enum mesa_log_level l)
-{
-   switch (l) {
-   case MESA_LOG_ERROR: return ANDROID_LOG_ERROR;
-   case MESA_LOG_WARN: return ANDROID_LOG_WARN;
-   case MESA_LOG_INFO: return ANDROID_LOG_INFO;
-   case MESA_LOG_DEBUG: return ANDROID_LOG_DEBUG;
-   }
-
-   unreachable("bad mesa_log_level");
-}
-
-static void
-logger_android(enum mesa_log_level level,
-               const char *tag,
-               const char *format,
-               va_list va)
-{
-   /* Android can truncate/drop messages
-    *
-    *  - the internal buffer for vsnprintf has a fixed size (usually 1024)
-    *  - the socket to logd is non-blocking
-    *
-    * and provides no way to detect.  Try our best.
-    */
-   char local_msg[1024];
-   char *msg = logger_vasnprintf(local_msg, sizeof(local_msg), 0, level, tag,
-         format, va);
-
-   __android_log_write(level_to_android(level), tag, msg);
-
-   if (msg != local_msg)
-      free(msg);
-
-   /* increase the chance of logd doing its part */
-   if (mesa_log_control & MESA_LOG_CONTROL_WAIT)
-      thrd_yield();
-}
-
-#endif /* DETECT_OS_ANDROID */
-
 #if DETECT_OS_WINDOWS
 
 static void
@@ -367,9 +315,7 @@ mesa_log_v(enum mesa_log_level level, const char *tag, const char *format,
 #if DETECT_OS_UNIX
       { MESA_LOG_CONTROL_SYSLOG, logger_syslog },
 #endif
-#if DETECT_OS_ANDROID
-      { MESA_LOG_CONTROL_ANDROID, logger_android },
-#endif
+
 #if DETECT_OS_WINDOWS
       { MESA_LOG_CONTROL_WINDBG, logger_windbg },
 #endif
diff --git a/src/util/os_misc.c b/src/util/os_misc.c
index 7261577488f..0f31f8b8f43 100644
--- a/src/util/os_misc.c
+++ b/src/util/os_misc.c
@@ -51,13 +51,7 @@
 
 #endif
 
-
-#if DETECT_OS_ANDROID
-#  define LOG_TAG "MESA"
-#  include <unistd.h>
-#  include <log/log.h>
-#  include <cutils/properties.h>
-#elif DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM
+#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM || DETECT_OS_ANDROID
 #  include <unistd.h>
 #elif DETECT_OS_OPENBSD || DETECT_OS_FREEBSD
 #  include <sys/resource.h>
@@ -122,59 +116,9 @@ os_log_message(const char *message)
    fflush(stdout);
    fputs(message, fout);
    fflush(fout);
-#  if DETECT_OS_ANDROID
-   LOG_PRI(ANDROID_LOG_ERROR, LOG_TAG, "%s", message);
-#  endif
 #endif
 }
 
-#if DETECT_OS_ANDROID
-#  include <ctype.h>
-#  include "c11/threads.h"
-
-/**
- * Get an option value from android's property system, as a fallback to
- * getenv() (which is generally less useful on android due to processes
- * typically being forked from the zygote.
- *
- * The option name used for getenv is translated into a property name
- * by:
- *
- *  1) convert to lowercase
- *  2) replace '_' with '.'
- *  3) if necessary, prepend "mesa."
- *
- * For example:
- *  - MESA_EXTENSION_OVERRIDE -> mesa.extension.override
- *  - GALLIUM_HUD -> mesa.gallium.hud
- *
- */
-static char *
-os_get_android_option(const char *name)
-{
-   static thread_local char os_android_option_value[PROPERTY_VALUE_MAX];
-   char key[PROPERTY_KEY_MAX];
-   char *p = key, *end = key + PROPERTY_KEY_MAX;
-   /* add "mesa." prefix if necessary: */
-   if (strstr(name, "MESA_") != name)
-      p += strlcpy(p, "mesa.", end - p);
-   p += strlcpy(p, name, end - p);
-   for (int i = 0; key[i]; i++) {
-      if (key[i] == '_') {
-         key[i] = '.';
-      } else {
-         key[i] = tolower(key[i]);
-      }
-   }
-
-   int len = property_get(key, os_android_option_value, NULL);
-   if (len > 1) {
-      return os_android_option_value;
-   }
-   return NULL;
-}
-#endif
-
 #if DETECT_OS_WINDOWS
 
 /* getenv doesn't necessarily reflect changes to the environment
@@ -195,11 +139,6 @@ const char *
 os_get_option(const char *name)
 {
    const char *opt = getenv(name);
-#if DETECT_OS_ANDROID
-   if (!opt) {
-      opt = os_get_android_option(name);
-   }
-#endif
    return opt;
 }
 
@@ -266,7 +205,7 @@ exit_mutex:
 bool
 os_get_total_physical_memory(uint64_t *size)
 {
-#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM
+#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM || DETECT_OS_ANDROID
    const long phys_pages = sysconf(_SC_PHYS_PAGES);
    const long page_size = sysconf(_SC_PAGE_SIZE);
 
@@ -320,7 +259,7 @@ os_get_total_physical_memory(uint64_t *size)
 bool
 os_get_available_system_memory(uint64_t *size)
 {
-#if DETECT_OS_LINUX
+#if DETECT_OS_LINUX || DETECT_OS_ANDROID
    char *meminfo = os_read_file("/proc/meminfo", NULL);
    if (!meminfo)
       return false;
diff --git a/src/util/u_process.c b/src/util/u_process.c
index 6ad19de416e..4cf86ecb1bb 100644
--- a/src/util/u_process.c
+++ b/src/util/u_process.c
@@ -103,7 +103,7 @@ __getProgramName()
 {
    return strdup(program_invocation_short_name);
 }
-#elif defined(__FreeBSD__) || defined(__DragonFly__) || defined(__APPLE__) || defined(ANDROID) || defined(__NetBSD__)
+#elif defined(__FreeBSD__) || defined(__DragonFly__) || defined(__APPLE__) || defined(__ANDROID__) || defined(__NetBSD__)
 #if defined(__NetBSD__)
 #    include <sys/param.h>
 #endif
@@ -170,7 +170,7 @@ __getProgramName()
 #endif
 
 #if defined(GET_PROGRAM_NAME_NOT_AVAILABLE)
-#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__UCLIBC__) || defined(ANDROID)
+#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__UCLIBC__) || defined(__ANDROID__)
 /* This is a hack. It's said to work on OpenBSD, NetBSD and GNU.
  * Rogelio M.Serrano Jr. reported it's also working with UCLIBC. It's
  * used as a last resort, if there is no documented facility available. */
diff --git a/src/virtio/vtest/vtest_protocol.h b/src/virtio/vtest/vtest_protocol.h
index c48be146ec5..351b312d737 100644
--- a/src/virtio/vtest/vtest_protocol.h
+++ b/src/virtio/vtest/vtest_protocol.h
@@ -25,7 +25,7 @@
 #ifndef VTEST_PROTOCOL
 #define VTEST_PROTOCOL
 
-#define VTEST_DEFAULT_SOCKET_NAME "/tmp/.virgl_test"
+#define VTEST_DEFAULT_SOCKET_NAME "/data/data/com.micewine.emu/files/usr/tmp/.virgl_test"
 
 #ifdef VIRGL_RENDERER_UNSTABLE_APIS
 #define VTEST_PROTOCOL_VERSION 3
diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index 3dc4a670cd7..30848b9f1e0 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -175,6 +175,12 @@ struct wsi_display_sync {
 
 static uint64_t fence_sequence;
 
+#ifdef __ANDROID__
+static void thread_signal_handler (int signum) {
+   pthread_exit (0);
+}
+#endif
+
 ICD_DEFINE_NONDISP_HANDLE_CASTS(wsi_display_mode, VkDisplayModeKHR)
 ICD_DEFINE_NONDISP_HANDLE_CASTS(wsi_display_connector, VkDisplayKHR)
 
@@ -1340,7 +1346,9 @@ wsi_display_wait_thread(void *data)
       .events = POLLIN
    };
 
+#ifndef __ANDROID__
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+#endif
    for (;;) {
       int ret = poll(&pollfd, 1, -1);
       if (ret > 0) {
@@ -1368,9 +1376,22 @@ wsi_display_start_wait_thread(struct wsi_display *wsi)
 static void
 wsi_display_stop_wait_thread(struct wsi_display *wsi)
 {
+#ifdef __ANDROID__
+   struct sigaction actions;
+   memset (&actions, 0, sizeof (actions));
+   sigemptyset (&actions.sa_mask);
+   actions.sa_flags = 0;
+   actions.sa_handler = thread_signal_handler;
+   sigaction (SIGUSR2, &actions, NULL);
+#endif
+
    pthread_mutex_lock(&wsi->wait_mutex);
    if (wsi->wait_thread) {
+#ifndef __ANDROID__
       pthread_cancel(wsi->wait_thread);
+#else
+      pthread_kill(wsi->wait_thread, SIGUSR2);
+#endif
       pthread_join(wsi->wait_thread, NULL);
       wsi->wait_thread = 0;
    }
@@ -2214,7 +2235,9 @@ udev_event_listener_thread(void *data)
 
    int udev_fd = udev_monitor_get_fd(mon);
 
+#ifndef __ANDROID__
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+#endif
 
    for (;;) {
       nfds_t nfds = 1;
@@ -2337,6 +2360,15 @@ wsi_display_finish_wsi(struct wsi_device *wsi_device,
    struct wsi_display *wsi =
       (struct wsi_display *) wsi_device->wsi[VK_ICD_WSI_PLATFORM_DISPLAY];
 
+#ifdef __ANDROID__
+   struct sigaction actions;
+   memset (&actions, 0, sizeof (actions));
+   sigemptyset (&actions.sa_mask);
+   actions.sa_flags = 0;
+   actions.sa_handler = thread_signal_handler;
+   sigaction (SIGUSR2, &actions, NULL);
+#endif
+
    if (wsi) {
       wsi_for_each_connector(connector, wsi) {
          wsi_for_each_display_mode(mode, connector) {
@@ -2348,7 +2380,11 @@ wsi_display_finish_wsi(struct wsi_device *wsi_device,
       wsi_display_stop_wait_thread(wsi);
 
       if (wsi->hotplug_thread) {
+#ifndef __ANDROID__
          pthread_cancel(wsi->hotplug_thread);
+#else
+         pthread_kill(wsi->hotplug_thread, SIGUSR2);
+#endif
          pthread_join(wsi->hotplug_thread, NULL);
       }
 
diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 0ac83108252..91dfca23be8 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -440,7 +440,7 @@ wsi_x11_get_connection(struct wsi_device *wsi_dev,
 
 static const VkFormat formats[] = {
    VK_FORMAT_R5G6B5_UNORM_PACK16,
-   VK_FORMAT_B8G8R8A8_SRGB,
+   // VK_FORMAT_B8G8R8A8_SRGB,
    VK_FORMAT_B8G8R8A8_UNORM,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32,
 };
@@ -1438,7 +1438,6 @@ x11_acquire_next_image_poll_find_index(struct x11_swapchain *chain, uint32_t *im
    for (uint32_t i = 0; i < chain->base.image_count; i++) {
       if (!chain->images[i].busy) {
          /* We found a non-busy image */
-         xshmfence_await(chain->images[i].shm_fence);
          *image_index = i;
          chain->images[i].busy = true;
          chain->present_poll_acquire_count++;
@@ -1594,7 +1593,6 @@ x11_acquire_next_image_from_queue(struct x11_swapchain *chain,
    }
 
    assert(image_index < chain->base.image_count);
-   xshmfence_await(chain->images[image_index].shm_fence);
 
    *image_index_out = image_index;
 
@@ -1637,8 +1635,6 @@ x11_present_to_x11_dri3(struct x11_swapchain *chain, uint32_t image_index,
       options |= XCB_PRESENT_OPTION_SUBOPTIMAL;
 #endif
 
-   xshmfence_reset(image->shm_fence);
-
    ++chain->sent_image_count;
    assert(chain->sent_image_count <= chain->base.image_count);
 
@@ -2220,14 +2216,23 @@ x11_image_init(VkDevice device_h, struct x11_swapchain *chain,
          return VK_ERROR_OUT_OF_HOST_MEMORY;
 
       cookie =
-         xcb_dri3_pixmap_from_buffer_checked(chain->conn,
-                                             image->pixmap,
-                                             chain->window,
-                                             image->base.sizes[0],
-                                             pCreateInfo->imageExtent.width,
-                                             pCreateInfo->imageExtent.height,
-                                             image->base.row_pitches[0],
-                                             chain->depth, bpp, fd);
+         xcb_dri3_pixmap_from_buffers_checked(chain->conn,
+                                              image->pixmap,
+                                              chain->window,
+                                              image->base.num_planes,
+                                              pCreateInfo->imageExtent.width,
+                                              pCreateInfo->imageExtent.height,
+                                              image->base.row_pitches[0],
+                                              image->base.offsets[0],
+                                              0,
+                                              0,
+                                              0,
+                                              0,
+                                              0,
+                                              0,
+                                              chain->depth, bpp,
+                                              1274,
+                                              &fd);
    }
 
    error = xcb_request_check(chain->conn, cookie);
@@ -2236,6 +2241,10 @@ x11_image_init(VkDevice device_h, struct x11_swapchain *chain,
       goto fail_image;
    }
 
+   image->sync_fence = 0;
+   image->busy = false;
+   return VK_SUCCESS;
+
 out_fence:
    fence_fd = xshmfence_alloc_shm();
    if (fence_fd < 0)
@@ -2278,10 +2287,6 @@ x11_image_finish(struct x11_swapchain *chain,
    xcb_void_cookie_t cookie;
 
    if (!chain->base.wsi->sw || chain->has_mit_shm) {
-      cookie = xcb_sync_destroy_fence(chain->conn, image->sync_fence);
-      xcb_discard_reply(chain->conn, cookie.sequence);
-      xshmfence_unmap_shm(image->shm_fence);
-
       cookie = xcb_free_pixmap(chain->conn, image->pixmap);
       xcb_discard_reply(chain->conn, cookie.sequence);
 
