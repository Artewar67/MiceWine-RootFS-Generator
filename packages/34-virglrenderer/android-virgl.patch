diff -uNr 34-virglrenderer/config.h.meson 34-virglrenderer.mod/config.h.meson
--- 34-virglrenderer/config.h.meson	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/config.h.meson	2024-03-04 22:42:34.440772000 +0000
@@ -55,3 +55,5 @@
 #mesondefine PIPE_ARCH_S390
 #mesondefine PIPE_ARCH_ARM
 #mesondefine PIPE_ARCH_AARCH64
+#mesondefine EGL_WITHOUT_GBM
+#mesondefine HAVE_LIBDRM
diff -uNr 34-virglrenderer/meson.build 34-virglrenderer.mod/meson.build
--- 34-virglrenderer/meson.build	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/meson.build	2024-03-04 22:42:34.440809000 +0000
@@ -66,7 +66,7 @@
 
 prog_python = import('python').find_installation('python3')
 
-libdrm_dep = dependency('libdrm', version : '>=2.4.50')
+libdrm_dep = dependency('libdrm', version : '>=2.4.50', required : false)
 thread_dep = dependency('threads')
 epoxy_dep = dependency('epoxy', version: '>= 1.5.4')
 m_dep = cc.find_library('m', required : false)
@@ -183,6 +183,10 @@
    add_global_arguments('-DDEBUG=1', language : 'c')
 endif
 
+if libdrm_dep.found()
+  conf_data.set('HAVE_LIBDRM', 1)
+endif
+
 platforms = get_option('platforms')
 
 require_egl = platforms.contains('egl')
@@ -195,8 +199,13 @@
 have_egl = false
 have_glx = false
 
+egl_without_gbm = get_option('egl_without_gbm')
+
 with_minigbm_allocation = get_option('minigbm_allocation')
 if with_minigbm_allocation
+   if egl_without_gbm
+      error('Cannot build gbm allocation without gbm')
+   endif
    conf_data.set('ENABLE_MINIGBM_ALLOCATION', 1)
    _gbm_ver = '18.0.0'
 else
@@ -205,8 +214,14 @@
 
 if with_egl
    if cc.has_header('epoxy/egl.h', dependencies: epoxy_dep) and epoxy_dep.get_pkgconfig_variable('epoxy_has_egl') == '1'
-      gbm_dep = dependency('gbm', version: '>= ' + _gbm_ver, required: require_egl)
-      have_egl = gbm_dep.found()
+      if egl_without_gbm
+         gbm_dep = dependency('', required : false)
+         have_egl = true
+         conf_data.set('EGL_WITHOUT_GBM', 1)
+      else
+         gbm_dep = dependency('gbm', version: '>= ' + _gbm_ver, required: require_egl)
+         have_egl = gbm_dep.found()
+      endif
       if (have_egl)
          conf_data.set('HAVE_EPOXY_EGL_H', 1)
       else
@@ -316,7 +331,7 @@
         'libdir': get_option('libdir'),
         }, section: 'Directories')
 summary({'c_args': (' ').join(get_option('c_args')),
-        'egl': have_egl,
+        'egl': (have_egl ? 'yes' : 'no') + (egl_without_gbm ? ' (no gbm)' : ''),
         'glx': have_glx,
         'minigbm_alloc': with_minigbm_allocation,
         'venus': with_venus,
diff -uNr 34-virglrenderer/meson_options.txt 34-virglrenderer.mod/meson_options.txt
--- 34-virglrenderer/meson_options.txt	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/meson_options.txt	2024-03-04 22:42:34.440837000 +0000
@@ -32,6 +32,13 @@
 )
 
 option(
+  'egl_without_gbm',
+  type : 'boolean',
+  value : 'false',
+  description : 'Build egl platform without gbm'
+)
+
+option(
   'minigbm_allocation',
   type : 'boolean',
   value : 'false',
diff -uNr 34-virglrenderer/src/gl4es-decompress.c 34-virglrenderer.mod/src/gl4es-decompress.c
--- 34-virglrenderer/src/gl4es-decompress.c	1970-01-01 00:00:00.000000000 +0000
+++ 34-virglrenderer.mod/src/gl4es-decompress.c	2024-03-04 22:44:08.569791000 +0000
@@ -0,0 +1,477 @@
+// Origin: https://github.com/alexvorxx/VirGL-Overlay-Rebuild/commit/d3052d9ee353d43867fa2fcf15ef072fcdaae2c4
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <epoxy/gl.h>
+
+#include "gl4es-decompress.h"
+
+/*
+DXT1/DXT3/DXT5 texture decompression
+The original code is from Benjamin Dobell, see below for details. Compared to
+the original this one adds DXT3 decompression, is valid C89, and is x64 
+compatible as it uses fixed size integers everywhere. It also uses a different
+PackRGBA order.
+---
+Copyright (c) 2012, Matthï¿½us G. "Anteru" Chajdas (http://anteru.net)
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in 
+the Software without restriction, including without limitation the rights to 
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
+of the Software, and to permit persons to whom the Software is furnished to do 
+so, subject to the following conditions:
+The above copyright notice and this permission notice shall be included in all 
+copies or substantial portions of the Software.
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
+SOFTWARE.
+---
+Copyright (C) 2009 Benjamin Dobell, Glass Echidna
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in 
+the Software without restriction, including without limitation the rights to 
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
+of the Software, and to permit persons to whom the Software is furnished to do 
+so, subject to the following conditions:
+The above copyright notice and this permission notice shall be included in all 
+copies or substantial portions of the Software.
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
+SOFTWARE.
+---
+*/
+static uint32_t PackRGBA (uint8_t r, uint8_t g, uint8_t b, uint8_t a)
+{
+	return r | (g << 8) | (b << 16) | (a << 24);
+}
+
+static void DecompressBlockDXT1Internal (const uint8_t* block,
+	uint32_t* output,
+	uint32_t outputStride,
+	int transparent0, int* simpleAlpha, int *complexAlpha,
+	const uint8_t* alphaValues)
+{
+	uint32_t temp, code;
+
+	uint16_t color0, color1;
+	uint8_t r0, g0, b0, r1, g1, b1;
+
+	int i, j;
+
+	color0 = *(const uint16_t*)(block);
+	color1 = *(const uint16_t*)(block + 2);
+
+	temp = (color0 >> 11) * 255 + 16;
+	r0 = (uint8_t)((temp/32 + temp)/32);
+	temp = ((color0 & 0x07E0) >> 5) * 255 + 32;
+	g0 = (uint8_t)((temp/64 + temp)/64);
+	temp = (color0 & 0x001F) * 255 + 16;
+	b0 = (uint8_t)((temp/32 + temp)/32);
+
+	temp = (color1 >> 11) * 255 + 16;
+	r1 = (uint8_t)((temp/32 + temp)/32);
+	temp = ((color1 & 0x07E0) >> 5) * 255 + 32;
+	g1 = (uint8_t)((temp/64 + temp)/64);
+	temp = (color1 & 0x001F) * 255 + 16;
+	b1 = (uint8_t)((temp/32 + temp)/32);
+
+	code = *(const uint32_t*)(block + 4);
+
+	if (color0 > color1) {
+		for (j = 0; j < 4; ++j) {
+			for (i = 0; i < 4; ++i) {
+				uint32_t finalColor, positionCode;
+				uint8_t alpha;
+
+				alpha = alphaValues [j*4+i];
+
+				finalColor = 0;
+				positionCode = (code >>  2*(4*j+i)) & 0x03;
+
+				switch (positionCode) {
+				case 0:
+					finalColor = PackRGBA(r0, g0, b0, alpha);
+					break;
+				case 1:
+					finalColor = PackRGBA(r1, g1, b1, alpha);
+					break;
+				case 2:
+					finalColor = PackRGBA((2*r0+r1)/3, (2*g0+g1)/3, (2*b0+b1)/3, alpha);
+					break;
+				case 3:
+					finalColor = PackRGBA((r0+2*r1)/3, (g0+2*g1)/3, (b0+2*b1)/3, alpha);
+					break;
+				}
+				if(transparent0 && (finalColor==0xff000000)) {
+					alpha=0;
+					finalColor = 0;
+				}
+				if(!alpha)
+					*simpleAlpha = 1;
+				else if(alpha<0xff)
+					*complexAlpha = 1;
+				output [j*outputStride + i] = finalColor;
+			}
+		}
+	} else {
+		for (j = 0; j < 4; ++j) {
+			for (i = 0; i < 4; ++i) {
+				uint32_t finalColor, positionCode;
+				uint8_t alpha;
+
+				alpha = alphaValues [j*4+i];
+
+				finalColor = 0;
+				positionCode = (code >>  2*(4*j+i)) & 0x03;
+
+				switch (positionCode) {
+				case 0:
+					finalColor = PackRGBA(r0, g0, b0, alpha);
+					break;
+				case 1:
+					finalColor = PackRGBA(r1, g1, b1, alpha);
+					break;
+				case 2:
+					finalColor = PackRGBA((r0+r1)/2, (g0+g1)/2, (b0+b1)/2, alpha);
+					break;
+				case 3:
+					finalColor = PackRGBA(0, 0, 0, alpha);
+					break;
+				}
+
+				if(transparent0 && (finalColor==0xff000000)) {
+					alpha = 0;
+					finalColor = 0;
+				}
+				if(!alpha)
+					*simpleAlpha = 1;
+				else if(alpha<0xff)
+					*complexAlpha = 1;
+
+				output [j*outputStride + i] = finalColor;
+			}
+		}
+	}
+}
+
+/*
+void DecompressBlockDXT1(): Decompresses one block of a DXT1 texture and stores the resulting pixels at the appropriate offset in 'image'.
+uint32_t x:						x-coordinate of the first pixel in the block.
+uint32_t y:						y-coordinate of the first pixel in the block.
+uint32_t width: 				width of the texture being decompressed.
+const uint8_t *blockStorage:	pointer to the block to decompress.
+uint32_t *image:				pointer to image where the decompressed pixel data should be stored.
+*/ 
+void DecompressBlockDXT1(uint32_t x, uint32_t y, uint32_t width,
+	const uint8_t* blockStorage,
+	int transparent0, int* simpleAlpha, int *complexAlpha,
+	uint32_t* image)
+{
+	static const uint8_t const_alpha [] = {
+		255, 255, 255, 255,
+		255, 255, 255, 255,
+		255, 255, 255, 255,
+		255, 255, 255, 255
+	};
+
+	DecompressBlockDXT1Internal (blockStorage,
+		image + x + (y * width), width, transparent0, simpleAlpha, complexAlpha, const_alpha);
+}
+
+/*
+void DecompressBlockDXT5(): Decompresses one block of a DXT5 texture and stores the resulting pixels at the appropriate offset in 'image'.
+uint32_t x:						x-coordinate of the first pixel in the block.
+uint32_t y:						y-coordinate of the first pixel in the block.
+uint32_t width: 				width of the texture being decompressed.
+const uint8_t *blockStorage:	pointer to the block to decompress.
+uint32_t *image:				pointer to image where the decompressed pixel data should be stored.
+*/ 
+void DecompressBlockDXT5(uint32_t x, uint32_t y, uint32_t width,
+	const uint8_t* blockStorage,
+	int transparent0, int* simpleAlpha, int *complexAlpha,
+	uint32_t* image)
+{
+	uint8_t alpha0, alpha1;
+	const uint8_t* bits;
+	uint32_t alphaCode1;
+	uint16_t alphaCode2;
+
+	uint16_t color0, color1;
+	uint8_t r0, g0, b0, r1, g1, b1;
+
+	int i, j;
+
+	uint32_t temp, code;
+
+	alpha0 = *(blockStorage);
+	alpha1 = *(blockStorage + 1);
+
+	bits = blockStorage + 2;
+	alphaCode1 = bits[2] | (bits[3] << 8) | (bits[4] << 16) | (bits[5] << 24);
+	alphaCode2 = bits[0] | (bits[1] << 8);
+
+	color0 = *(const uint16_t*)(blockStorage + 8);
+	color1 = *(const uint16_t*)(blockStorage + 10);	
+
+	temp = (color0 >> 11) * 255 + 16;
+	r0 = (uint8_t)((temp/32 + temp)/32);
+	temp = ((color0 & 0x07E0) >> 5) * 255 + 32;
+	g0 = (uint8_t)((temp/64 + temp)/64);
+	temp = (color0 & 0x001F) * 255 + 16;
+	b0 = (uint8_t)((temp/32 + temp)/32);
+
+	temp = (color1 >> 11) * 255 + 16;
+	r1 = (uint8_t)((temp/32 + temp)/32);
+	temp = ((color1 & 0x07E0) >> 5) * 255 + 32;
+	g1 = (uint8_t)((temp/64 + temp)/64);
+	temp = (color1 & 0x001F) * 255 + 16;
+	b1 = (uint8_t)((temp/32 + temp)/32);
+
+	code = *(const uint32_t*)(blockStorage + 12);
+
+	for (j = 0; j < 4; j++) {
+		for (i = 0; i < 4; i++) {
+			uint8_t finalAlpha;
+			int alphaCode, alphaCodeIndex;
+			uint8_t colorCode;
+			uint32_t finalColor;
+
+			alphaCodeIndex = 3*(4*j+i);
+			if (alphaCodeIndex <= 12) {
+				alphaCode = (alphaCode2 >> alphaCodeIndex) & 0x07;
+			} else if (alphaCodeIndex == 15) {
+				alphaCode = (alphaCode2 >> 15) | ((alphaCode1 << 1) & 0x06);
+			} else /* alphaCodeIndex >= 18 && alphaCodeIndex <= 45 */ {
+				alphaCode = (alphaCode1 >> (alphaCodeIndex - 16)) & 0x07;
+			}
+
+			if (alphaCode == 0) {
+				finalAlpha = alpha0;
+			} else if (alphaCode == 1) {
+				finalAlpha = alpha1;
+			} else {
+				if (alpha0 > alpha1) {
+					finalAlpha = (uint8_t)(((8-alphaCode)*alpha0 + (alphaCode-1)*alpha1)/7);
+				} else {
+					if (alphaCode == 6) {
+						finalAlpha = 0;
+					} else if (alphaCode == 7) {
+						finalAlpha = 255;
+					} else {
+						finalAlpha = (uint8_t)(((6-alphaCode)*alpha0 + (alphaCode-1)*alpha1)/5);
+					}
+				}
+			}
+
+			colorCode = (code >> 2*(4*j+i)) & 0x03; 
+			finalColor = 0;
+
+			switch (colorCode) {
+			case 0:
+				finalColor = PackRGBA(r0, g0, b0, finalAlpha);
+				break;
+			case 1:
+				finalColor = PackRGBA(r1, g1, b1, finalAlpha);
+				break;
+			case 2:
+				finalColor = PackRGBA((2*r0+r1)/3, (2*g0+g1)/3, (2*b0+b1)/3, finalAlpha);
+				break;
+			case 3:
+				finalColor = PackRGBA((r0+2*r1)/3, (g0+2*g1)/3, (b0+2*b1)/3, finalAlpha);
+				break;
+			}
+
+			if(finalAlpha==0) *simpleAlpha = 1;
+			else if(finalAlpha<0xff) *complexAlpha = 1;
+
+			image [i + x + (width* (y+j))] = finalColor; 
+		}
+	}
+}
+
+/*
+void DecompressBlockDXT3(): Decompresses one block of a DXT3 texture and stores the resulting pixels at the appropriate offset in 'image'.
+uint32_t x:						x-coordinate of the first pixel in the block.
+uint32_t y:						y-coordinate of the first pixel in the block.
+uint32_t height:				height of the texture being decompressed.
+const uint8_t *blockStorage:	pointer to the block to decompress.
+uint32_t *image:				pointer to image where the decompressed pixel data should be stored.
+*/ 
+void DecompressBlockDXT3(uint32_t x, uint32_t y, uint32_t width,
+	const uint8_t* blockStorage,
+	int transparent0, int* simpleAlpha, int *complexAlpha,
+	uint32_t* image)
+{
+	int i;
+
+	uint8_t alphaValues [16] = { 0 };
+
+	for (i = 0; i < 4; ++i) {
+		const uint16_t* alphaData = (const uint16_t*) (blockStorage);
+
+		alphaValues [i*4 + 0] = (((*alphaData) >> 0) & 0xF ) * 17;
+		alphaValues [i*4 + 1] = (((*alphaData) >> 4) & 0xF ) * 17;
+		alphaValues [i*4 + 2] = (((*alphaData) >> 8) & 0xF ) * 17;
+		alphaValues [i*4 + 3] = (((*alphaData) >> 12) & 0xF) * 17;
+
+		blockStorage += 2;
+	}
+
+	DecompressBlockDXT1Internal (blockStorage,
+		image + x + (y * width), width, transparent0, simpleAlpha, complexAlpha, alphaValues);
+}
+
+static int inline nlevel(int size, int level) {
+    if(size) {
+        size>>=level;
+        if(!size) size=1;
+    }
+    return size;
+}
+
+// return the max level for that WxH size
+static int inline maxlevel(int w, int h) {
+    int mlevel = 0;
+    while(w!=1 || h!=1) {
+        w>>=1; h>>=1;
+        if(!w) w=1;
+        if(!h) h=1;
+        ++mlevel;
+    }
+    return mlevel;
+}
+
+static GLboolean isDXTc(GLenum format) {
+    switch (format) {
+        case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+        case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+        case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
+            return 1;
+    }
+    return 0;
+}
+
+GLboolean isDXTcSRGB(GLenum format) {
+    switch (format) {
+        case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
+            return 1;
+    }
+    return 0;
+}
+
+GLboolean isDXTcAlpha(GLenum format) {
+    switch (format) {
+        case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+        case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
+            return 1;
+    }
+    return 0;
+}
+
+static GLboolean isNotCompressed(GLenum format) {
+    switch(format) {
+        case GL_RGBA:
+        case GL_RGB:
+        case GL_RGBA8:
+        case GL_RGB8:
+        case GL_RGB5:
+        case GL_RGB565:
+            return true;
+    }
+    return false;
+}
+
+static GLenum compressedMinMipmap(GLenum param)
+{
+    switch(param) {
+        case GL_NEAREST_MIPMAP_NEAREST:
+        case GL_NEAREST_MIPMAP_LINEAR:
+            return GL_NEAREST;
+        case GL_LINEAR_MIPMAP_NEAREST:
+        case GL_LINEAR_MIPMAP_LINEAR:
+            return GL_LINEAR;
+        default:
+            return param;
+    }
+}
+
+GLvoid *uncompressDXTc(GLsizei width, GLsizei height, GLenum format, GLsizei imageSize,
+                        int transparent0, int* simpleAlpha, int* complexAlpha, const GLvoid *data)
+{
+    // uncompress a DXTc image
+    // get pixel size of uncompressed image => fixed RGBA
+    int pixelsize = 4;
+
+/*	if (format==COMPRESSED_RGB_S3TC_DXT1_EXT)
+        pixelsize = 3;*/
+    // check with the size of the input data stream if the stream is in fact uncompressed
+    if (imageSize == width*height*pixelsize || data==NULL) {
+        // uncompressed stream
+        return (GLvoid*)data;
+    }
+    // alloc memory
+    GLvoid *pixels = malloc(((width+3)&~3)*((height+3)&~3)*pixelsize);
+    // uncompress loop
+    int blocksize;
+    switch (format) {
+        case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
+            blocksize = 8;
+            break;
+        case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+        case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
+        case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
+        case GL_RGBA_DXT5_S3TC:
+            blocksize = 16;
+            break;
+    }
+    uintptr_t src = (uintptr_t) data;
+    for (int y=0; y<height; y+=4) {
+        for (int x=0; x<width; x+=4) {
+            switch(format) {
+                case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
+                case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+                case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
+                case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
+                    DecompressBlockDXT1(x, y, width, (uint8_t*)src, transparent0, simpleAlpha, complexAlpha, pixels);
+                    break;
+                case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+                case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
+                    DecompressBlockDXT3(x, y, width, (uint8_t*)src, transparent0, simpleAlpha, complexAlpha, pixels);
+                    break;
+                case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+                case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
+                case GL_RGBA_DXT5_S3TC:
+                    DecompressBlockDXT5(x, y, width, (uint8_t*)src, transparent0, simpleAlpha, complexAlpha, pixels);
+                    break;
+            }
+            src+=blocksize;
+        }
+    }
+    return pixels;
+}
diff -uNr 34-virglrenderer/src/gl4es-decompress.h 34-virglrenderer.mod/src/gl4es-decompress.h
--- 34-virglrenderer/src/gl4es-decompress.h	1970-01-01 00:00:00.000000000 +0000
+++ 34-virglrenderer.mod/src/gl4es-decompress.h	2024-03-04 22:44:08.569830000 +0000
@@ -0,0 +1,29 @@
+#ifndef _GL4ES_DECOMPRESS_H_
+#define _GL4ES_DECOMPRESS_H_
+
+#include <stdint.h>
+#include <epoxy/gl.h>
+
+void DecompressBlockDXT1(uint32_t x, uint32_t y, uint32_t width,
+	const uint8_t* blockStorage,
+	int transparent0, int* simpleAlpha, int *complexAlpha,
+	uint32_t* image);
+
+void DecompressBlockDXT3(uint32_t x, uint32_t y, uint32_t width,
+	const uint8_t* blockStorage,
+	int transparent0, int* simpleAlpha, int *complexAlpha,
+	uint32_t* image);
+
+void DecompressBlockDXT5(uint32_t x, uint32_t y, uint32_t width,
+	const uint8_t* blockStorage,
+	int transparent0, int* simpleAlpha, int *complexAlpha,
+	uint32_t* image);
+
+GLboolean isDXTcSRGB(GLenum format);
+
+GLboolean isDXTcAlpha(GLenum format);
+
+GLvoid *uncompressDXTc(GLsizei width, GLsizei height, GLenum format, GLsizei imageSize,
+                       int transparent0, int* simpleAlpha, int* complexAlpha, const GLvoid *data);
+
+#endif // _GL4ES_DECOMPRESS_H_
diff -uNr 34-virglrenderer/src/meson.build 34-virglrenderer.mod/src/meson.build
--- 34-virglrenderer/src/meson.build	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/src/meson.build	2024-03-04 22:44:08.569861000 +0000
@@ -55,6 +55,7 @@
    'vrend_tweaks.h',
    'vrend_winsys.c',
    'vrend_winsys.h',
+   'gl4es-decompress.c',
 ]
 
 virglrenderer_sources = [
@@ -64,12 +65,17 @@
 ]
 
 vrend_winsys_egl_sources = [
-   'vrend_winsys_gbm.c',
-   'vrend_winsys_gbm.h',
    'vrend_winsys_egl.c',
    'vrend_winsys_egl.h',
 ]
 
+if not egl_without_gbm
+   vrend_winsys_egl_sources += [
+      'vrend_winsys_gbm.c',
+      'vrend_winsys_gbm.h',
+   ]
+endif
+
 vrend_winsys_glx_sources = [
    'vrend_winsys_glx.c',
    'vrend_winsys_glx.h',
diff -uNr 34-virglrenderer/src/vrend_formats.c 34-virglrenderer.mod/src/vrend_formats.c
--- 34-virglrenderer/src/vrend_formats.c	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/src/vrend_formats.c	2024-03-04 22:44:08.569894000 +0000
@@ -534,6 +534,8 @@
 #define add_formats(x) vrend_add_formats((x), ARRAY_SIZE((x)))
 #define add_compressed_formats(x) vrend_add_compressed_formats((x), ARRAY_SIZE((x)))
 
+extern int dxtn_decompress;
+
 void vrend_build_format_list_common(void)
 {
   add_formats(base_rgba_formats);
@@ -564,7 +566,7 @@
   /* compressed */
   if (epoxy_has_gl_extension("GL_S3_s3tc") ||
       epoxy_has_gl_extension("GL_EXT_texture_compression_s3tc") ||
-      epoxy_has_gl_extension("GL_ANGLE_texture_compression_dxt")) {
+      epoxy_has_gl_extension("GL_ANGLE_texture_compression_dxt") || dxtn_decompress) {
      add_compressed_formats(dxtn_formats);
      add_compressed_formats(dxtn_srgb_formats);
   }
diff -uNr 34-virglrenderer/src/vrend_renderer.c 34-virglrenderer.mod/src/vrend_renderer.c
--- 34-virglrenderer/src/vrend_renderer.c	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/src/vrend_renderer.c	2024-03-04 22:44:08.569972000 +0000
@@ -68,6 +68,17 @@
 #include <vrend_video.h>
 #endif
 
+#include "gl4es-decompress.h"
+const int dxtn_decompress = 1;
+static void CheckGlError( const char* pFunctionName )
+{
+   GLint error = glGetError();
+   if( error != GL_NO_ERROR )
+   {
+      printf("%s returned glError 0x%x\n", pFunctionName, error);
+   }
+}
+
 /*
  * VIRGL_RENDERER_CAPSET_VIRGL has version 0 and 1, but they are both
  * virgl_caps_v1 and are exactly the same.
@@ -386,6 +397,14 @@
 
 static inline bool has_feature(enum features_id feature_id)
 {
+#ifdef __ANDROID__
+   // On Adreno, this feature cannot be used.
+   // Maybe related to https://gitlab.freedesktop.org/virgl/virglrenderer/-/issues/223 
+   // and https://developer.qualcomm.com/forum/qdn-forums/software/adreno-gpu-sdk/34738
+   if (feature_id == feat_dual_src_blend) {
+      return false;
+   }
+#endif
    int slot = feature_id / 64;
    uint64_t mask = 1ull << (feature_id & 63);
    bool retval = vrend_state.features[slot] & mask ? true : false;
@@ -7444,7 +7463,7 @@
    grctx->shader_cfg.has_es31_compat = has_feature(feat_gles31_compatibility);
    grctx->shader_cfg.has_conservative_depth = has_feature(feat_conservative_depth);
    grctx->shader_cfg.use_integer = vrend_state.use_integer;
-   grctx->shader_cfg.has_dual_src_blend = has_feature(feat_dual_src_blend);
+   grctx->shader_cfg.has_dual_src_blend = false;
    grctx->shader_cfg.has_fbfetch_coherent = has_feature(feat_framebuffer_fetch);
    grctx->shader_cfg.has_cull_distance = has_feature(feat_cull_distance);
    grctx->shader_cfg.has_nopersective = has_feature(feat_shader_noperspective_interpolation);
@@ -8457,6 +8476,9 @@
 {
    void *data;
 
+   GLvoid *decompressed_data;
+   short decompress_success = 0;
+
    if ((is_only_bit(res->storage_bits, VREND_STORAGE_GUEST_MEMORY) ||
        has_bit(res->storage_bits, VREND_STORAGE_HOST_SYSTEM_MEMORY)) && res->iov) {
       return vrend_copy_iovec(iov, num_iovs, info->offset,
@@ -8645,10 +8667,65 @@
             else
                vrend_scale_depth(data, send_size, depth_scale);
          }
+         if (compressed && dxtn_decompress) {
+            // from gl4es code
+            int simpleAlpha = 0;
+            int complexAlpha = 0;
+            int transparent0 = (glformat == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
+                                 glformat == GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT) ? 1 : 0;
+
+            if(isDXTcAlpha(glformat))
+               simpleAlpha = complexAlpha = 1;
+
+            if (data) {
+               if ((info->box->width & 3) || (info->box->height & 3)) {
+                     GLvoid *tmp;
+                     GLsizei nw = info->box->width;
+                     GLsizei nh = info->box->height;
+                     int y_tmp;
+                     if (nw < 4) nw = 4;
+                     if (nh < 4) nh = 4;
+                     tmp = uncompressDXTc(nw, nh, glformat, comp_size, transparent0,
+                                          &simpleAlpha, &complexAlpha, data);
+                     decompressed_data = malloc(4 * info->box->width * info->box->height);
+
+                     for (y_tmp = 0; y_tmp < info->box->height; y_tmp ++)
+                        memcpy(decompressed_data + y_tmp * info->box->width * 4, tmp + y_tmp * nw * 4,
+                              info->box->width * 4);
+                     free(tmp);
+               } else {
+                     decompressed_data = uncompressDXTc(info->box->width, info->box->height, glformat,
+                                                      comp_size, transparent0, &simpleAlpha, &complexAlpha, data);
+               }
+            }
+
+            if((gltype != GL_UNSIGNED_BYTE) && isDXTcSRGB(glformat)) {
+
+               if(simpleAlpha && !complexAlpha) {
+                     glformat = GL_RGBA;
+                     gltype = GL_UNSIGNED_SHORT_5_5_5_1;
+               } else if(complexAlpha || simpleAlpha) {
+                     glformat = GL_RGBA;
+                     gltype = GL_UNSIGNED_SHORT_4_4_4_4;
+               } else {
+                     glformat = GL_RGB;
+                     gltype = GL_UNSIGNED_SHORT_5_6_5;
+               }
+            } else {
+               glformat = GL_RGBA;
+            }
+            decompress_success = 1;
+         }
          if (res->target == GL_TEXTURE_CUBE_MAP) {
             GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + info->box->z;
             if (compressed) {
-               glCompressedTexSubImage2D(ctarget, info->level, x, y,
+               if (dxtn_decompress) {
+                  glTexImage2D(ctarget, info->level, glformat, info->box->width,
+                              info->box->height, 0, glformat, gltype, decompressed_data);
+                  CheckGlError("glTexImage2D");
+               }
+               else
+                  glCompressedTexSubImage2D(ctarget, info->level, x, y,
                                          info->box->width, info->box->height,
                                          glformat, comp_size, data);
             } else {
@@ -8657,7 +8734,14 @@
             }
          } else if (res->target == GL_TEXTURE_3D || res->target == GL_TEXTURE_2D_ARRAY || res->target == GL_TEXTURE_CUBE_MAP_ARRAY) {
             if (compressed) {
-               glCompressedTexSubImage3D(res->target, info->level, x, y, info->box->z,
+               if (dxtn_decompress) {
+                  glTexImage3D(res->target, info->level, glformat,
+                              info->box->width, info->box->height, info->box->depth,
+                              0, glformat, gltype, decompressed_data);
+                  CheckGlError("glTexImage3D");
+               }
+               else
+                  glCompressedTexSubImage3D(res->target, info->level, x, y, info->box->z,
                                          info->box->width, info->box->height, info->box->depth,
                                          glformat, comp_size, data);
             } else {
@@ -8666,7 +8750,12 @@
                                glformat, gltype, data);
             }
          } else if (res->target == GL_TEXTURE_1D) {
-            if (vrend_state.use_gles) {
+            if (compressed && dxtn_decompress) {
+               glTexImage1D(res->target, info->level, glformat, info->box->width,
+                           0, glformat, gltype, decompressed_data);
+               CheckGlError("glTexImage1D");
+            }
+            else if (vrend_state.use_gles) {
                /* Covers both compressed and none compressed. */
                report_gles_missing_func(ctx, "gl[Compressed]TexSubImage1D");
             } else if (compressed) {
@@ -8679,7 +8768,18 @@
             }
          } else {
             if (compressed) {
-               glCompressedTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,
+               if (dxtn_decompress) {
+                  glTexImage2D(res->target, info->level, glformat, info->box->width,
+                              info->box->height, 0, glformat, gltype, NULL);
+                  CheckGlError("glTexImage2D");
+                  glTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,
+                                 info->box->width,
+                                 res->target == GL_TEXTURE_1D_ARRAY ? info->box->depth : info->box->height,
+                                 glformat, gltype, decompressed_data);
+                  CheckGlError("glTexSubImage2D");
+               }
+               else
+                  glCompressedTexSubImage2D(res->target, info->level, x, res->target == GL_TEXTURE_1D_ARRAY ? info->box->z : y,
                                          info->box->width, info->box->height,
                                          glformat, comp_size, data);
             } else {
@@ -8702,6 +8802,9 @@
 
       glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
 
+      if (decompress_success)
+         free(decompressed_data);
+
       if (need_temp)
          free(data);
    }
@@ -12283,7 +12386,7 @@
 
    /* resource is still untyped */
    if (!res->pipe_resource) {
-#ifdef HAVE_EPOXY_EGL_H
+#if defined(HAVE_EPOXY_EGL_H) && !defined(EGL_WITHOUT_GBM)
       const struct vrend_renderer_resource_create_args create_args = {
          .target = PIPE_TEXTURE_2D,
          .format = args->format,
diff -uNr 34-virglrenderer/src/vrend_renderer.h 34-virglrenderer.mod/src/vrend_renderer.h
--- 34-virglrenderer/src/vrend_renderer.h	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/src/vrend_renderer.h	2024-03-04 22:42:49.569159000 +0000
@@ -32,7 +32,12 @@
 #include "vrend_debug.h"
 #include "vrend_tweaks.h"
 #include "vrend_iov.h"
+#ifdef EGL_WITHOUT_GBM
+#define VIRGL_GBM_MAX_PLANES 4
+#include "virglrenderer.h"
+#else
 #include "vrend_winsys_gbm.h"
+#endif
 #include "virgl_hw.h"
 #include <epoxy/gl.h>
 
diff -uNr 34-virglrenderer/src/vrend_winsys.c 34-virglrenderer.mod/src/vrend_winsys.c
--- 34-virglrenderer/src/vrend_winsys.c	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/src/vrend_winsys.c	2024-03-04 22:42:49.569191000 +0000
@@ -52,6 +52,7 @@
 {
    if (flags & VIRGL_RENDERER_USE_EGL) {
 #ifdef HAVE_EPOXY_EGL_H
+#ifndef EGL_WITHOUT_GBM
       /*
        * If the user specifies a preferred DRM fd and we can't use it, fail. If the user doesn't
        * specify an fd, it's possible to initialize EGL without one.
@@ -59,15 +60,16 @@
       gbm = virgl_gbm_init(preferred_fd);
       if (preferred_fd > 0 && !gbm)
          return -1;
-
+#endif
       egl = virgl_egl_init(gbm, flags & VIRGL_RENDERER_USE_SURFACELESS,
                            flags & VIRGL_RENDERER_USE_GLES);
       if (!egl) {
+#ifndef EGL_WITHOUT_GBM
          if (gbm) {
             virgl_gbm_fini(gbm);
             gbm = NULL;
          }
-
+#endif
          return -1;
       }
 
@@ -99,10 +101,12 @@
       virgl_egl_destroy(egl);
       egl = NULL;
       use_context = CONTEXT_NONE;
+#ifndef EGL_WITHOUT_GBM
       if (gbm) {
          virgl_gbm_fini(gbm);
          gbm = NULL;
       }
+#endif
    } else if (use_context == CONTEXT_EGL_EXTERNAL) {
       free(egl);
       egl = NULL;
@@ -201,7 +205,7 @@
 
 int vrend_winsys_get_fourcc_for_texture(uint32_t tex_id, uint32_t format, int *fourcc)
 {
-#ifdef HAVE_EPOXY_EGL_H
+#if defined(HAVE_EPOXY_EGL_H) && !defined(EGL_WITHOUT_GBM)
    if (use_context == CONTEXT_EGL)
       return virgl_egl_get_fourcc_for_texture(egl, tex_id, format, fourcc);
 #else
@@ -214,7 +218,7 @@
 
 int vrend_winsys_get_fd_for_texture(uint32_t tex_id, int *fd)
 {
-#ifdef HAVE_EPOXY_EGL_H
+#if defined(HAVE_EPOXY_EGL_H) && !defined(EGL_WITHOUT_GBM)
    if (!egl)
       return -1;
 
@@ -228,7 +232,7 @@
 
 int vrend_winsys_get_fd_for_texture2(uint32_t tex_id, int *fd, int *stride, int *offset)
 {
-#ifdef HAVE_EPOXY_EGL_H
+#if defined(HAVE_EPOXY_EGL_H) && !defined(EGL_WITHOUT_GBM)
    if (!egl)
       return -1;
 
diff -uNr 34-virglrenderer/src/vrend_winsys.h 34-virglrenderer.mod/src/vrend_winsys.h
--- 34-virglrenderer/src/vrend_winsys.h	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/src/vrend_winsys.h	2024-03-04 22:42:49.569220000 +0000
@@ -28,7 +28,9 @@
 #include "config.h"
 
 #ifdef HAVE_EPOXY_EGL_H
+#ifndef EGL_WITHOUT_GBM
 #include "vrend_winsys_gbm.h"
+#endif
 #include "vrend_winsys_egl.h"
 #endif
 
diff -uNr 34-virglrenderer/src/vrend_winsys_egl.c 34-virglrenderer.mod/src/vrend_winsys_egl.c
--- 34-virglrenderer/src/vrend_winsys_egl.c	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/src/vrend_winsys_egl.c	2024-03-04 22:43:19.443007000 +0000
@@ -36,7 +36,9 @@
 #include <poll.h>
 #include <stdbool.h>
 #include <unistd.h>
+#ifdef HAVE_LIBDRM
 #include <xf86drm.h>
+#endif
 
 #include "util/u_memory.h"
 
@@ -44,7 +46,9 @@
 #include "vrend_winsys.h"
 #include "vrend_winsys_egl.h"
 #include "virgl_hw.h"
+#ifndef EGL_WITHOUT_GBM
 #include "vrend_winsys_gbm.h"
+#endif
 #include "virgl_util.h"
 
 #define EGL_KHR_SURFACELESS_CONTEXT            BIT(0)
@@ -297,13 +301,15 @@
 
    if (surfaceless)
       conf_att[1] = EGL_PBUFFER_BIT;
+#ifndef EGL_WITHOUT_GBM
    else if (!gbm)
       goto fail;
 
    egl->gbm = gbm;
+#endif
    egl->different_gpu = false;
    const char *client_extensions = eglQueryString (NULL, EGL_EXTENSIONS);
-
+#ifndef EGL_WITHOUT_GBM
 #ifdef ENABLE_MINIGBM_ALLOCATION
    if (virgl_egl_get_display(egl)) {
      /* Make -Wdangling-else happy. */
@@ -325,15 +331,16 @@
    } else {
       egl->egl_display = eglGetDisplay((EGLNativeDisplayType)egl->gbm->device);
    }
-
+#endif
    if (!egl->egl_display) {
+#ifndef EGL_WITHOUT_GBM
       /*
        * Don't fallback to the default display if the fd provided by (*get_drm_fd)
        * can't be used.
        */
       if (egl->gbm && egl->gbm->fd < 0)
          goto fail;
-
+#endif
       egl->egl_display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
       if (!egl->egl_display)
          goto fail;
@@ -344,14 +351,14 @@
       goto fail;
 
    extensions = eglQueryString(egl->egl_display, EGL_EXTENSIONS);
-#ifdef VIRGL_EGL_DEBUG
+// #ifdef VIRGL_EGL_DEBUG
    vrend_printf( "EGL major/minor: %d.%d\n", major, minor);
    vrend_printf( "EGL version: %s\n",
            eglQueryString(egl->egl_display, EGL_VERSION));
    vrend_printf( "EGL vendor: %s\n",
            eglQueryString(egl->egl_display, EGL_VENDOR));
    vrend_printf( "EGL extensions: %s\n", extensions);
-#endif
+// #endif
 
    if (virgl_egl_init_extensions(egl, extensions))
       goto fail;
@@ -417,21 +424,25 @@
    egl->egl_display = egl_display;
 
    extensions = eglQueryString(egl->egl_display, EGL_EXTENSIONS);
-#ifdef VIRGL_EGL_DEBUG
+// #ifdef VIRGL_EGL_DEBUG
    vrend_printf( "EGL version: %s\n",
            eglQueryString(egl->egl_display, EGL_VERSION));
    vrend_printf( "EGL vendor: %s\n",
            eglQueryString(egl->egl_display, EGL_VENDOR));
    vrend_printf( "EGL extensions: %s\n", extensions);
-#endif
+// #endif
 
    if (virgl_egl_init_extensions(egl, extensions)) {
       free(egl);
       return NULL;
    }
 
+#ifndef EGL_WITHOUT_GBM
    gbm = virgl_gbm_init(-1);
    egl->gbm = gbm;
+#else
+   egl->gbm = NULL;
+#endif
 
    return egl;
 }
@@ -470,7 +481,7 @@
    EGLContext egl_ctx = eglGetCurrentContext();
    return (virgl_renderer_gl_context)egl_ctx;
 }
-
+#ifndef EGL_WITHOUT_GBM
 int virgl_egl_get_fourcc_for_texture(struct virgl_egl *egl, uint32_t tex_id, uint32_t format, int *fourcc)
 {
    int ret = EINVAL;
@@ -569,7 +580,7 @@
    eglDestroyImageKHR(egl->egl_display, image);
    return ret;
 }
-
+#endif
 bool virgl_has_egl_khr_gl_colorspace(struct virgl_egl *egl)
 {
    return has_bit(egl->extension_bits, EGL_KHR_GL_COLORSPACE);
diff -uNr 34-virglrenderer/vtest/vtest_protocol.h 34-virglrenderer.mod/vtest/vtest_protocol.h
--- 34-virglrenderer/vtest/vtest_protocol.h	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/vtest/vtest_protocol.h	2024-03-04 22:44:39.434181000 +0000
@@ -25,7 +25,7 @@
 #ifndef VTEST_PROTOCOL
 #define VTEST_PROTOCOL
 
-#define VTEST_DEFAULT_SOCKET_NAME "/tmp/.virgl_test"
+#define VTEST_DEFAULT_SOCKET_NAME "/data/data/com.termux/files/usr/tmp/.virgl_test"
 
 #ifdef VIRGL_RENDERER_UNSTABLE_APIS
 #define VTEST_PROTOCOL_VERSION 3
diff -uNr 34-virglrenderer/vtest/vtest_server.c 34-virglrenderer.mod/vtest/vtest_server.c
--- 34-virglrenderer/vtest/vtest_server.c	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/vtest/vtest_server.c	2024-03-04 22:43:26.766069000 +0000
@@ -254,6 +254,13 @@
       server.multi_clients = false;
    }
 
+#ifdef __ANDROID__
+   // On Android, ensure that EGL and GLES is used.
+   server.use_egl_surfaceless = true;
+   server.use_glx = false;
+   server.use_gles = true;
+#endif
+
    server.ctx_flags = VIRGL_RENDERER_USE_EGL;
    if (server.use_glx) {
       if (server.use_egl_surfaceless || server.use_gles) {
@@ -373,6 +380,7 @@
 static void vtest_server_open_socket(void)
 {
    struct sockaddr_un un;
+   const char* socket_name = os_get_option("VTEST_RENDERER_SOCKET_NAME");
 
    server.socket = socket(PF_UNIX, SOCK_STREAM, 0);
    if (server.socket < 0) {
@@ -382,7 +390,8 @@
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
 
-   snprintf(un.sun_path, sizeof(un.sun_path), "%s", server.socket_name);
+   snprintf(un.sun_path, sizeof(un.sun_path), "%s", socket_name ?
+      socket_name : server.socket_name);
 
    unlink(un.sun_path);
 
diff -uNr 34-virglrenderer/vtest/vtest_shm.c 34-virglrenderer.mod/vtest/vtest_shm.c
--- 34-virglrenderer/vtest/vtest_shm.c	2023-01-02 16:12:17.000000000 +0000
+++ 34-virglrenderer.mod/vtest/vtest_shm.c	2024-03-04 22:43:16.169626000 +0000
@@ -44,6 +44,30 @@
 #endif
 }
 
+#ifdef __ANDROID__
+#include <sys/ioctl.h>
+static int vtest_new_android_ashm(size_t size)
+{
+   int fd, ret;
+   long flags;
+   fd = open("/dev/ashmem", O_RDWR | O_CLOEXEC);
+   if (fd < 0)
+      return fd;
+   ret = ioctl(fd, /* ASHMEM_SET_SIZE */ _IOW(0x77, 3, size_t), size);
+   if (ret < 0)
+      goto err;
+   flags = fcntl(fd, F_GETFD);
+   if (flags == -1)
+      goto err;
+   if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
+      goto err;
+   return fd;
+   err:
+   close(fd);
+   return -1;
+}
+#endif
+
 int vtest_new_shm(uint32_t handle, size_t size)
 {
    int fd, ret;
@@ -54,6 +78,12 @@
    fd = memfd_create(str, MFD_ALLOW_SEALING);
    free(str);
    if (fd < 0) {
+#ifdef __ANDROID__
+      fd = vtest_new_android_ashm(size);
+      if (fd > 0) {
+         return fd;
+      }
+#endif
       return report_failed_call("memfd_create", -errno);
    }
 
@@ -68,6 +98,10 @@
 
 int vtest_shm_check(void)
 {
+#ifdef __ANDROID__
+    return 1;
+#endif
+
     int mfd = memfd_create("test", MFD_ALLOW_SEALING);
 
     if (mfd >= 0) {
